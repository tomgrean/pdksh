# pdksh enhanced
pdksh: public domain korn shell with configured auto completion.
---
My pdksh project is mainly focusing on interactive shells.
I use vi editing mode, so I will try to fix any bug found in it. I added supports for arrow keys and Home, End, PgUp, PgDn, so the cursor can be moved easier.

I also added programmed tab-completion, just like bash. It's kind of complicated, though, and there still may be bugs. OK, let me introduce the programmed tab-completion to you.

First of all, you may need to edit your $HOME/.kshrc to setup your tab-completion configuration. Some lines of mine look like:

```ksh
# interactive shell only
[[ "$-" == *i* ]] || return
PS1='$USER@${PWD}$ '
# list of alias and predefined function/variable.
#...
#...
#...
[[ "$KSH_VERSION" == *PD* ]] || return
# command completions
complete 'sudo=C'
complete 'git=S:add,:status,:commit,clone,:diff,:log'
complete 'svn=S:add,:status,:commit,checkout,@--diff-cmd,:diff,:log'
function _systemctl {
	typeset ACT="enable disable start stop restart status reload"
	case $# in
	0)
		_COMPLETE=$ACT
		;;
	1)
		if [[ -z "$1" ]]; then
			_COMPLETE=$ACT
		else
			typeset -i i=0
			typeset outs
			typeset a
			for a in $ACT; do
				if [[ ${a#$1} != $a ]]; then
					outs[$((i++))]=$a
				fi
			done
			_COMPLETE="${outs[@]}"
		fi
		;;
	*)
		shift $(($# - 1))
		_COMPLETE=$(cd /lib/systemd/system;
		if [ -z "$1" ];then
			echo *
		elif echo $1* |grep -F '*' > /dev/null 2>&1;then
			:
		else
			echo $1*
		fi)
		;;
	esac
}
complete 'systemctl=F_systemctl'

function _modprobe {
	if [[ $# -le 0 ]]; then return; fi
	while [[ x$1 = x-* ]]; do
		shift
	done
	_COMPLETE=$(find /lib/modules/$(uname -r) -type f -name "$1*.ko" -printf '%f\n'|sed 's/\.ko//g')
}
complete 'modprobe=F_modprobe'

function _manpage {
	typeset manid='?'
	if [[ $# -ge 1 && $1 = [0-9] ]]; then
		manid=$1
		shift
	fi
	# only for non-empty completion.
	if [[ $# == 1 && -n $1 ]]; then
		if [[ ${1##*/} != $1 ]]; then
			_COMPLETE=$(echo $1*)
		else
			_COMPLETE=$(find /usr/share/man/man$manid -name "$1*" -printf '%f\n'|sed 's/\.[0-9]\..*//g'|sort|uniq)
		fi
	else
		_COMPLETE=
	fi
}
complete 'man=F_manpage'


#key bindings
bind '\033[A=up'
bind '\033[B=down'
bind '\033[C=right'
bind '\033[D=left'
bind '\033[H=home' '\033[F=end' '\033[5~=up' '\033[6~=down'
bind '\033[3~=del' '\033[2~=ins'
```
As you may already figure it out. There is a new builtin command _complete_. We use the command to make customized tab-completion work as expected.

The builtin _complete_ has three kinds of arguments. listed below:

1. _COMMAND_NAME_=C
    indicates that the word following _COMMAND_NAME_ should be a command.
2. _COMMAND_NAME_=S*ARG_LIST*
    indicates that the word following _COMMAND_NAME_ should be a customized _ARG_ joined by "," and may be prefixed by ":" or "@" in _ARG_LIST_.
    
    The prefix ":" means the _ARG_ needs a file name argument, while "@" means the _ARG_ needs a command name argument.
3. _COMMAND_NAME_=F*FUNC*
    indicates that the word following _COMMAND_NAME_ should be generated by calling shell function _FUNC_.
    
    Arguments passed to function _FUNC_ is all what you have already typed in the current command line.
    
    In function _FUNC_, generated candidate-string list, should be assigned to \_COMPLETE variable. Do __NOT__ print anything out, unless you know what you are doing.
    
    All variable except \_COMPLETE within _FUNC_, should be declared with _typeset_ or _local_ keyword, making them exist only within the function.


Support for bind built-in now available! It's usage is similar to emacs editing mode. Currently supported binding name include *up*, *down*, *right*, *left*, *home*, *end*, *del*, *ins*.
